# 第二章 : 算法基础

## 第一节 : 插入排序

### 内容

- 循环不变式 :

  - 循环每次迭代开始前和结束后, 总是成立的某些条件
  - 主要用来帮助理解算法

- 证明循环不变式 :

  1. 初始化 : 循环的第一次迭代之前, 它为真
  2. 保持 : 如果循环的上一次迭代它为真, 则下一次同样为真
  3. 终止 : 在循环的终止, 循环不变式仍然为真

- 与数学归纳法的区别是, 这里的归纳不是 "无限" 的, 而是会在终止条件的位置, 终止归纳

- 插入排序 :

  - 就像是整理手牌的过程

  - 伪代码 : 

    - ```python
      for j=2 to A.length=n // A[1....n]
      	key = A[j]
      	i = j - 1
      	while A[i] > key & i > 0
      		A[i] = key
      		i--
          A[i+1] = A[i]
      ```

  - 手上有一堆没有整理好的手牌, 我们需要从小到大将他们排序好

    1. 将牌区分为两部分, 一部分是排序好的, 另一部分是未排序的
    2. 初始情况 : 第一张牌位于排序好的牌区, 因为一张牌可以认为是排序好的
    3. 迭代 : 我们按顺序从未排序区域拿出一张新的牌, 然后将牌与前面的牌进行比较, 找到一个位置
       j-1 < key < j, 这个位置就是我们插入新牌位置
    4. 插入新牌

- 插入排序中的循环不变式

  - 目的 : 证明插入排序的正确性 ; 循环不变式 : j之前的序列是有序的
  - 初始化 : 证明第一次迭代之前, 循环不变式成立
    - 第一次迭代以前 : (j = 2), 这个时候有序序列只有一张牌, 很明显是有序的
  - 保持 : 证明每一次迭代, 如果迭代之前循环不变式成立, 那么迭代后同样成立
    - 非形式化的说明 : 我们将A[j-1], A[j-2], A[j-3]等元素向右边移动一个位置, 直到找到一个合适的位置, 我们再将key的值插入其中, 我们在迭代后, 我们仍然保持了有序序列的顺序, 也就是
  - 终止 : 研究最后循环终止的时候发生了什么
    - 循环终止的时候 j = n + 1, 那么序列A[1-n]均为有序的, 而这就是整个数组, 所以整个数组都是有序的了


### 练习

 2. 重写一个降序的插入排序

    - ```python
      for j=2 to A.length=n
      	key = A[j]
          i = j-1
          while i > 0 and A[i] < key
          	A[i+1] = A[i]
              i--
          A[i+1] = key
      ```

3. 查找问题

   - ```python
     i = NIL
     for j=1 to A.length
     	if A[j] == v
         	i = j
         	break
     return i
     ```

4. 循环不变式 : j左边的区域没有和V相等的值

   - 初始化 : j左边的区域没有元素, 自然没有

   - 保持 : 如果在迭代之前的j左边的区域没有和V相等的元素, 在迭代过程中, 如果A[j]元素等于的v, 则会直接break, 也保证了j左边的区域没有和V相等的值, 如果A[j]不等于则将这个元素添加以后, j左边的区域仍然是没有和v相等的元素

   - 终止 : 最后的时候, 如果出现了元素 == v, 则循环停止在找到元素的那以状态, 而j左边的元素都是不和v相等的, 则和v相等的元素就是A[j], 而返回的i=j, 则成功找到; 如果没有找到, 则i时钟为NIL

5. 将两个n位的二进制整数加起来的问题

   1. 问题的形式化描述

      - 输入 : 两个n元数组的地址

      - 输出 : 储存了两个整数和的n元数组C的地址

      - 约束条件 : 这两个n元数组储存的是两个二进制整数

      - 目标 : 将两个二进制整数相加, 并返回加和

   2. 伪代码

      - ```python
        C.initAllElem = 0
        for i=A.length downto 0
        	C[i+1] = A[i] + B[i]
            if C[i+1] == 2 //进位
            	C[i] = 1
        ```

## 第二节 : 分析算法

### 内容

- RAM模型
  - 问题 : 我们现在需要去计算一个算法运行的时间, 这里有个问题就是我们需要规定清楚什么指令, 它的运行时间是常量, 也就是计算运行时间的最小单元O(1)
  - 我们规定使用RAM(random-access machine)模型作为我们用于运行我们技术的模型
  - 这个模型没有并发运算, 只有线性的运行指令, 以及在我们理解的常规的范围内的指令 : 算数指令, 数据移动指令, 控制指令, 我们都视为运行时间为常量的模型
  - 存在灰色区域的指令, 比如指数运算, 这条指令在受限的范围内是常量运算时间
  - RAM模型, 一般不对内存层次进行建模
- 输入规模  :
  - 最佳概念依赖于问题
  - EG :
    - 对于排序问题, 输入规模指的是输入中的项数
    - 两个整数相乘, 输入规模的最佳度量是通用二进制记号表示输入所需的总位数
    - 输入是一个图的话,  输入规模可以用该图中的顶点和边数来描述
- 运行时间:
  - 执行的基本操作数或步数
- 当一个for循环或while循环按照通常的方式 ( 即在循环头退出 ) 退出时, 执行测试的次数比执行循环体的次数多1
- $\sum^n_{j=2} {t_j}$表示在第j次迭代过程中, 循环体内的子循环执行的次数
- 我们往往只考虑最坏情况, 理由有三 :
  - 最坏情况给出了算法运行时间的上界, 能保障算法运行时间绝不需要更多的时间
  - 在某些情况下, 最坏情况常常出现, 比如对于数据库的检索而言, 检索不存在的值是一件很常见的事情
  - "平均情况" 往往和最坏情况一样差
- 增长量级 :
  - 我们往往采用一种更加抽象和简化的形式描述算法的运行时间, 只关注运行时间的增长量级, 只考虑对大小影响最大的项

### 练习

1. $\Theta(n^3)$

2. 选择算法的伪代码, 循环不变式是什么, 为什么只需要对前n-1个元素, 而不是所有n个元素运行, 给出它最好情况和最坏情况运行时间

   1. 伪代码 
      ```python
      A[1...n]
      for i=1 to A.length-1
      	min = A[i]
      	for j=i to A.length
          	if min > A[j]
              	min = A[j]
          SWAP(min, A[j])
      ```

   2. 循环不变式 : 

      1. 数组被分成了前面的已排序部分和后面的未排序部分
      2. 已排序部分中的每个元素都小于未排序部分的所有元素
      3. 已排序部分按升序排列

   3. 初始化与保持省略证明, 终止状态下, 已排序序列是[1...n-1], 未排序序列是[n],  而由循环不变式, 我们能得出, [1...n-1]序列中的所有元素都小于[n]中的元素, 故A[n]就是最大的元素, 所以整个数组已经按照升序排列好了

3. 线性查找问题的平均需要查找n/2个元素, 最坏情况需要查找n个元素, 平均情况和最坏情况运行时间均为$\Theta(n)$ 

4. 获得良好的最好情况运行时间

   - 添加预检查步骤, 在算法主体之前添加一个快速检查来识别"最好情况"的输入. 如果检查到这种情况, 直接返回结果或者走专门的优化路径
   - 添加分支执行优化代码路径
   - 缓存或记忆, 以快速识别可能导致最佳性能的特征

## 第三节 : 设计算法

### 分治法

#### 内容

- 分治法的步骤
  1. 分解原问题为较小的子问题, 这些子问题是原问题的较小的实例
  2. 解决这些子问题, 递归地求解子问题, 然而子问题的规模足够小, 能够直接求解,这里也是递归的返回点
  3. 合并这些子问题的解成原问题的解

- 归并排序与递归
  - 分解 : 分解待排序的长度为n序列为两个长度为2/n的子序列
  - 解决 : 使用归并排序递归地排序两个子序列
  - 合并 : 合并两个已经排序好了的子序列以产生已排序的答案

- 归并排序的核心是合并, 即将两个已经排序好了子序列合并为一个新的序列

  - 现在有两堵牌堆, 两个牌堆现在都已经各自按照升序(顶部是最小的牌)排列好了, 我们现在需要将它们合并为一个新的牌堆, 我们去比较两个牌堆顶部的牌哪边的更小, 将更小的那一边的牌放在新牌堆的最下面, 循环往返, 最后产生的新牌堆就是两个子牌堆合并产生的已经排序好的新牌堆

  - 伪代码
    ```python
    MERGE(A, p, q, r)
    	n1 = q - p + 1 //第一个牌堆的里牌的数量
        n2 = r - q + 1
     	let L[1...n1+1] and R[1...n2+1] be new arrays
        for i = 1 to n1
        	L[i] = A[i]
    	for i = n1 + 1 to n2
        	R[i-n1] = A[i]
        L[n1+1] = R[n2+1] = INF
      	i = j = 1
        for k = p to r
        	if L[i] > R[j]
            	A[k] = R[j]
                j++
            else A[k] = L[i]
            	i++
    ```

  - 我们设置了一个哨兵节点用于标记其中一个牌堆已经清空了, 这个哨兵节点的值为$\infty$所以无论什么值和它比较都会使比它小的值, 从而会被放到新牌堆里

- 循环不变式及证明

  - 循环不变式 : 11 - 16行for循环的每次迭代时, 子数组A[p...k-1] 按从小到大的顺序包含了L[1...n1+1]和R[1...n2+1]中k-p个最小的元素, 进而L[i]和R[j]是各自所在数组未被复制回A的最小的元素
  - **初始化** : 循环的第一次迭代以前, k=p, 数组A[p...k-1]为空, 故其按从小到大的顺序包含了L[1...n1+1]和R[1...n2+1]中0个最小的元素, 并且i=j=1, L[i], R[j]是各自所在数组未被复制回A的最小的元素
  - **保持** : 进行一次迭代以后, L[i]和R[j]较小的那个元素被复制回A中, 则增加了A[k]后的子数字A[p...k]将包含k-p+1个最小元素,  将对应的索引++, 并增加k的值, 从而维持了循环不变式
  - **终止** : 按照循环不变式, 子数组A[p..k-1], 也就是A[p..r]按照从小到大的顺序包含了两个子数组L与R中的r-p+1个最小元素, 而L与R共同包含r-p+3个元素, 除了最大的元素都已返回到A中

- MERGE-SORT(A, p, r)

  ```python
  MERGE-SORT(A, p, r)
  	q = (p + r)/2
      MERGE-SORT(A, p, q)
      MERGE-SORT(A, q+1, r)
      MERGE(A, p, q, r)
  ```

### 分析分治算法

#### 内容

- 对于递归式$T(n)=2T(n/2) + cn$, 在完全拓展了的递归树中有$lgn+1$层, 每层因为MERGE操作, 贡献总代价cn, 所以总代价为$cnlgn+cn$也就是$\Theta(nlgn)$

- 详细证明过程原书的叙述在原书中有精彩与详细的叙述, 这里不予赘述

#### 练习

2. 重写MERGE, 放弃哨兵节点, 而是其中一个牌堆清空以后 , 直接将另一个牌堆全部复制上去

   ```python
   MERGE(A, p, q, r)
       n1 = q - p + 1
       n2 = r - q
       let L[1..n1] and R[1..n2] be new arrays
   	for i=1 to n1
       	L[i] = A[i+p-1]
       for i=1 to n2
       	R[i] = A[i+q]
       i = j = 1
     	for k = p to r
       	if i <= n1 and (j > n2 or L[i] <= R[j])
           	A[k] = L[i]
               i++
           else 
           	A[k] = R[j]
               j++
   ```

   

