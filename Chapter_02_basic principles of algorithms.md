# 第二章 : 算法基础

### 第一节 : 插入排序

### 内容

- 循环不变式 :

  - 循环每次迭代开始前和结束后, 总是成立的某些条件
  - 主要用来帮助理解算法

- 证明循环不变式 :

  1. 初始化 : 循环的第一次迭代之前, 它为真
  2. 保持 : 如果循环的上一次迭代它为真, 则下一次同样为真
  3. 终止 : 在循环的终止, 循环不变式仍然为真

- 与数学归纳法的区别是, 这里的归纳不是 "无限" 的, 而是会在终止条件的位置, 终止归纳

- 插入排序 :

  - 就像是整理手牌的过程

  - 伪代码 : 

    - ```python
      for j=2 to A.length=n // A[1....n]
      	key = A[j]
      	i = j - 1
      	while A[i] > key & i > 0
      		A[i] = key
      		i--
          A[i+1] = A[i]
      ```

  - 手上有一堆没有整理好的手牌, 我们需要从小到大将他们排序好

    1. 将牌区分为两部分, 一部分是排序好的, 另一部分是未排序的
    2. 初始情况 : 第一张牌位于排序好的牌区, 因为一张牌可以认为是排序好的
    3. 迭代 : 我们按顺序从未排序区域拿出一张新的牌, 然后将牌与前面的牌进行比较, 找到一个位置
       j-1 < key < j, 这个位置就是我们插入新牌位置
    4. 插入新牌

- 插入排序中的循环不变式

  - 目的 : 证明插入排序的正确性 ; 循环不变式 : j之前的序列是有序的
  - 初始化 : 证明第一次迭代之前, 循环不变式成立
    - 第一次迭代以前 : (j = 2), 这个时候有序序列只有一张牌, 很明显是有序的
  - 保持 : 证明每一次迭代, 如果迭代之前循环不变式成立, 那么迭代后同样成立
    - 非形式化的说明 : 我们将A[j-1], A[j-2], A[j-3]等元素向右边移动一个位置, 直到找到一个合适的位置, 我们再将key的值插入其中, 我们在迭代后, 我们仍然保持了有序序列的顺序, 也就是
  - 终止 : 研究最后循环终止的时候发生了什么
    - 循环终止的时候 j = n + 1, 那么序列A[1-n]均为有序的, 而这就是整个数组, 所以整个数组都是有序的了


### 练习

 2. 重写一个降序的插入排序

    - ```python
      for j=2 to A.length=n
      	key = A[j]
          i = j-1
          while i > 0 and A[i] < key
          	A[i+1] = A[i]
              i--
          A[i+1] = key
      ```

3. 查找问题

   - ```python
     i = NIL
     for j=1 to A.length
     	if A[j] == v
         	i = j
         	break
     return i
     ```

4. 循环不变式 : j左边的区域没有和V相等的值

   - 初始化 : j左边的区域没有元素, 自然没有

   - 保持 : 如果在迭代之前的j左边的区域没有和V相等的元素, 在迭代过程中, 如果A[j]元素等于的v, 则会直接break, 也保证了j左边的区域没有和V相等的值, 如果A[j]不等于则将这个元素添加以后, j左边的区域仍然是没有和v相等的元素

   - 终止 : 最后的时候, 如果出现了元素 == v, 则循环停止在找到元素的那以状态, 而j左边的元素都是不和v相等的, 则和v相等的元素就是A[j], 而返回的i=j, 则成功找到; 如果没有找到, 则i时钟为NIL

5. 将两个n位的二进制整数加起来的问题

   1. 问题的形式化描述

      - 输入 : 两个n元数组的地址

      - 输出 : 储存了两个整数和的n元数组C的地址

      - 约束条件 : 这两个n元数组储存的是两个二进制整数

      - 目标 : 将两个二进制整数相加, 并返回加和

   2. 伪代码

      - ```python
        C.initAllElem = 0
        for i=A.length downto 0
        	C[i+1] = A[i] + B[i]
            if C[i+1] == 2 //进位
            	C[i] = 1
        ```

## 第二节 : 分析算法

### 内容







