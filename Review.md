# 复习

- 每周完成学习以后会在改文档记录本周的学习内容, 以帮助学习与记忆, 以及便于未来的回顾和快速回忆

# 需要学的内容

- [ ] 第四章 : 分治策略
- [ ] 第七章 : 快速排序

- [ ] 第十二章 : 二叉搜索树
- [ ] 第十三章 : 红黑树
- [ ] 第十一章 : 散列表
- [ ] 第十五章 : 动态规划
- [ ] 第十六章 : 贪心算法
- [ ] 第十七章 : 摊还分析
- [ ] 第二十二章 : 基本的图算法
- [ ] 第二十三章 : 最小生成树
- [ ] 第二十四章 : 单源最短路径
- [ ] 第二十五章 : 所有结点对的最短路径问题
- [ ] 第三十一章 : 数论算法
- [ ] 第三十二章 : 字符串匹配

# 下一周需要学习的内容

- [ ] 第四章 : 分治策略
- [ ] 第七章 : 快速排序

- [ ] 第十二章 : 二叉搜索树
- [ ] 第十三章 : 红黑树

# 第一周回顾 ( 2024/09/02 - 2024/09/08)

## 知识点

### 算法基础 

#### 复杂度分析

- 基础概念 : 
  1. 要求$f(n)$是渐进非负的
  2. 后续的符号表示的是一系列函数的集合, 比如"$O(g(n))$"表示以下函数的集合  :
     $O(g(n)) = \{ f(n) : \text{存在正常量} \, c \, \text{和} \, n_0 \, \text{使得对所有} \, n \geq n_0 \, \text{有} \, 0 \leq f(n) \leq c g(n) \}$
  3. 渐进 : 渐进分析忽略了算法复杂度的常数项和低阶项, 只关心输入规模n很大的时候主导项的增长速度
  4. 紧确 : 即最精准的上界或下界

- $\Theta$
  - 非形式化定义 : 存在正常量$c_1$ 与 $c_2$, 使得对于足够大的n而言, $f(n)$能被"夹入"$c_1g(n)$与$c_2g(n)$中, 则称$f(n) \in \Theta(g(n))$也记作$f(n)=\Theta(g(n))$
  - 通俗说明 :  函数$f(n)$既有渐进紧确上界, 又有渐进紧确下界, 且上下界均可用$cg(n)$表示, 例如 : 对于函数$f(n) = n^2 + 12$n, $cn^2$就既是它的紧确上界, 也是它的紧确下界, 则此时$f(n)=\Theta(n^2)$

- $O$
  - 非形式化定义 : 对在$n_0$及其右边的所有值$n$, 函数$f(n)$的值总小于或等于$cg(n)$
  - 通俗说明 : 在想说明$g(n)$既是$f(n)$的渐进紧确上界, 又是渐进紧确下界的时候, 我们使用$\Theta$, 当只是想说明$g(n)$是渐进上界的时候, 我们使用$O$
  - 可以是紧确的, 也可以是不紧确的, 我们只关注是否是渐进分析

- $\Omega$ 
  - 非形式化定义 : 和$O$的定义类似, 就是将小于换成大于
  - 通俗说明 : 只是想说明渐进下界的时候使用$\Omega$
  - 可以是紧确的, 也可以是不紧确的, 我们只关注是否是渐进分析

- $o$
  - 非形式化定义 : $O$表示的是渐进上界, 而$o$表示的是非渐进紧确的上界, 在$f(n)=O(g(n))$中, 界$0 \le f(n) \le cg(n)$对某个$c>0$成立, 在$f(n)=o(g(n))$中, 界$0 \le f(n) \le cg(n)$对所有常量$c>0$成立
  - 通俗说明 : 这是更严格的上界表示, 说明$g(n)$永远大于$f(n)$, 而不只是一个渐进的或者紧确的上界, 是一种严格的上界, 常用来表示非紧确的上界
  - 从极限出发的定义 : $\lim_{n \to \infty} \frac{f(n)}{g(n)} = 0$ 

- $\omega$
  - 从极限出发的定义 : $\lim_{n \to \infty} \frac{f(n)}{g(n)} = \infty$ 


#### 算法验证

- 循环不变式
  - 引入 : 如果我们想证明一个算法的部分或完整正确性, 我们可以使用循环不变式这个工具
  - 定义 : 每次循环迭代开始时都成立的某种条件, 它通常满足以下三个条件
    1. 初始化 : 即第一次循环迭代开始之前, 循环不变式成立
    2. 保持 : 在某次迭代开始时循环不变式为真, 在迭代结束后, 循环不变式仍然为真
    3. 终止 : 在循环结束时, 循环不变式的成立加上循环结束的条件, 能证明算法的正确性或证明问题已经解决了
  - 和数学归纳法的对比 : 这种证明其实就是数学归纳法, 但是数学归纳法证明的问题中, 是证明无限次数的n, 而在循环不变式的证明中, 问题的迭代次数是有限的(循环是会退出的)
  - ❗提示 : 循环不变式并不是只有一个条件的, 一个循环不变式中很大概率在维持着多个条件

### 分治

- 分治算法分析的步骤
  - 分解 : 将问题划分为一些子问题, 但是子问题的规模更小, 且子问题在形式上与原问题相同
  - 解决 : 递归地求解子问题. 如果子问题地规模足够小, 则停止递归, 直接求解
  - 合并 : 将子问题合并为原问题地解

- 举例 : 详见归并排序

### 排序

#### 比较模型排序

- 插入排序
  - 思路
  - 伪代码实现
  - 复杂度分析
  
- 堆排序
  - 思路
  - 伪代码实现
  - 复杂度分析
- 归并排序
  - 思路
  - 伪代码实现
  - 复杂度分析

#### 非比较模型排序

- 计数排序
  - 思路
  - 伪代码实现
  - 复杂度分析
- 桶排序
  - 思路
  - 伪代码实现
  - 复杂度分析
- 基数排序
  - 思路
  - 伪代码实现
  - 复杂度分析

### 数据结构

#### 队列

- 概念

- 用队列实现栈 (伪代码)


#### 栈

- 概念

- 用栈实现队列 (伪代码)


#### 二叉树

- 概念

#### 堆

- 概念
- 常用方法的实现 (伪代码)
  - 复杂度分析


#### 优先队列



