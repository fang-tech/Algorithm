# Introduction to Algorithm

##  Chapter 10 : 基础数据结构

### 10.1 : 栈和队列

#### 栈

- 上溢 : 栈的上溢为栈满的时候, 仍然PUSH元素

  - ```
    Stack.top + 1 == length
    ```

- 下溢 : 栈为空的时候仍然POP元素

  - ```
    Stack.isEmpty == True
    ```

#### 队列

- 上溢 : 队列满的时候, 仍然ENQUEUE元素

  - ```
    (Q.tail + 1) % length == Q.head

- 下溢 : 队列为空的时候, 仍然DEQUEUE元素

  - ```
    Q.head == Q.tail
    ```

#### 使用栈实现队列与使用队列实现栈

- 两个栈实现队列

  1. 先将s1的数据逐个pop至s2
  2. 将新元素push入s2
  3. 将s2的数据pop至s1

- 两个队列实现栈

  1. 将新元素enqueue入q2

  2. 先将q1的数据逐个enqueue至q2
  3. 将q2的数据逐个enqueue至q1

- 本质 :

  - 不改变POP, 改变PUSH
  - 通过Stack将数据"灌入"另一个容器的时候, 数据的顺序倒置, Queue将数据"灌入"另一个容器的时候, 数据的顺序不变, 从而将新的数据插入到头(尾)

### 10.2 : 链表

- 10-2-4 对于Insert的优化
  - 优化目标 : 省略每次迭代中对 x ≠L.nil 的检查
  - 设置一个哨兵结点,放在链表尾, 让它的值等于key
- 10-2-5 UNION操作的实现
  - 具有头尾结点的单向链表

### 10.3 : 指针和对象的实现

- 问题背景
  - 部分语言中, 并没有对于指针和对象的描述, 我们在这种环境下, 如何构建链表和对象等结构呢

#### 对象的多数组表示

- 解决的问题 -> 如何在没有对象的语言中 通过多个数组实现对象

- 实现的方法

  - 创建多个数组, 每个数组表示一个属性
  - 将数组"对齐"地放入内容, 那么通过一个index, 我们就能在不同属性地数组中, 找到这个index对应的属性

- 例子 : 

  - ```伪代码
    # 有对象的语言中
    struct student{
    	int id;
    	string name;
    }
    student stus[100]; # 创建了100学生对象
    ```

  - ```伪代码
    # 没有对象的语言中
    #define length 100
    
    {
    	int id[length];
    	string name[length];
    } # 创建了100个学生对象
    
    ```

- 使用情景

  - 我们需要创建的对象是同构的, 即我们要管理的是同构的数据, 相对应的, 就是异构的数据, 我们通过下一种结构表示

#### 对象的单数组表示

- 解决的问题  -> 如何在没有对象的语言中, 通过单个数组实现对象

- 实现的方法

  - 概念1 : 在计算机中的对象和指针从内存的角度考虑 一个对象在计算机内存中占用一组连续的储存单元. 指针仅仅是该对象所在的连续储存单元的第一个储存单元的地址
  - 申请足够大的连续储存单元, 在其中不断放入"数据单元"

- 例子 : 这里的例子会比较复杂, 以链表的实现为例子

  - ```伪代码
    struct Node{
    	int data;
    	Node* next;
    	Node* prev;
    }
    
    list.push_back(int elem){ # 尾插入
    	Node* newNode = new Node(elem);
    	list.tail.next = newNode;
    	newNode->next = nullptr;
    	newNode->prev = list.tail;
    	list.tail = newNode;
    }
    ```

  - ```伪代码
    #define ENOUGH_LENGTH 1000
    
    int memory[ENOUGH_LENGTH]; # 申请足够大的内存单元
    
    //key : int 数据, next : int 该结点的下一个结点的偏移量, prev : int 该结点的上一个位置的偏移量
    //三个属性之间排列结构为|key|next|prev|
    //一个对象占用一段连续的子内存[j,...,k](这里的j和k均为索引)
    //对象中的每个属性对应0到k-j之间的一个偏移量, 指向该对象的指针就是下标j
    //这个概念需要图辅助理解, 建议参考原书 p135 
    //使用伪代码很难说明这个的实现, 故不给出伪代码
    ```

- 使用情景

  - 因为是在一块连续的内存中, 不需要"对齐", 所以我们理论上能存储异构的数据

#### 对象的分配与释放

- 解决的问题, -> 我们需要管理我们的内存, 得知哪些位置是空闲的可以放入数据(用于申请内存或者新建结点), 以及管理内存的释放
- 我们以多数组的双向链表实现为例, 探讨同构对象的分配和释放的过程
- 实现过程
  - 将自由对象保存在一个表中, 这个表也就称作自由表
  - 这个表只是用next数组, 用于表示下一个可用的位置, 这个表类似于一个栈, ALLOCATE的时候出栈, FREE的时候被释放的位置入栈

 